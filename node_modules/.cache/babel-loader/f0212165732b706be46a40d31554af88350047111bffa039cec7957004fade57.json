{"ast":null,"code":"import { useRef, useCallback, useMemo } from 'react';\nimport { createObserver, observeElement, unobserveElement } from './observer';\nimport { thresholdCacheKey } from './utils';\nvar noop = function () {};\n/**\n * useIntersectionObserver hook that has almost the same api as <Observer />\n *\n * @param {ChangeHandler} onChange Function that will be invoked whenever the intersection value for this element changes.\n * @param {Options} options Option to customize instersction observer instance or disable it\n *\n * @example\n * const App = () => {\n *   const onChange = ({ isIntersecting }) => console.log({ isIntersecting })\n *   const ref = useIntersectionObserver(onChange)\n *\n *   return <div ref={ref} />\n * }\n */\nexport var useIntersectionObserver = function (\n/**\n * Function that will be invoked whenever the intersection value for this element changes.\n */\nonChange, _a) {\n  var _b = _a === void 0 ? {} : _a,\n    root = _b.root,\n    rootMargin = _b.rootMargin,\n    threshold = _b.threshold,\n    disabled = _b.disabled;\n  var observingRef = useRef(false);\n  var instanceRef = useRef({\n    // unobserve function needs an instance and instance.handleChange needs an unobserve to be caught by closure.\n    // So it's essentially a circular reference that's resolved by assigning handleChange later\n    handleChange: function (event) {\n      /* istanbul ignore next line */\n      onChange(event, noop);\n    }\n  });\n  var unobserve = useCallback(function () {\n    if (instanceRef.current.target && observingRef.current) {\n      unobserveElement(instanceRef.current, instanceRef.current.target);\n      observingRef.current = false;\n    }\n  }, []);\n  instanceRef.current.handleChange = function handleChange(event) {\n    /* istanbul ignore next line */\n    onChange(event, unobserve);\n  };\n  var observe = function () {\n    if (instanceRef.current.observer && instanceRef.current.target && !observingRef.current) {\n      observeElement(instanceRef.current);\n      observingRef.current = true;\n    }\n  };\n  var memoizedThreshold = useMemo(function () {\n    return threshold;\n  }, [thresholdCacheKey(threshold)]);\n  var observer = useMemo(function () {\n    if (disabled) {\n      unobserve();\n      instanceRef.current.observer = undefined;\n      return undefined;\n    }\n    var rootOption = typeof root === 'string' ? document.querySelector(root) : root;\n    var obs = createObserver({\n      root: rootOption,\n      rootMargin: rootMargin,\n      threshold: memoizedThreshold\n    });\n    instanceRef.current.observer = obs;\n    unobserve();\n    observe();\n    return obs;\n  }, [root, rootMargin, memoizedThreshold, disabled]);\n  var setRef = useCallback(function (node) {\n    var isNewNode = node != null && instanceRef.current.target !== node;\n    if (!observer) {\n      unobserve();\n    }\n    if (isNewNode) {\n      unobserve();\n      instanceRef.current.target = node;\n      observe();\n    }\n    if (!node) {\n      unobserve();\n      instanceRef.current.target = undefined;\n    }\n  }, [observer]);\n  return [setRef, unobserve];\n};","map":{"version":3,"names":["useRef","useCallback","useMemo","createObserver","observeElement","unobserveElement","thresholdCacheKey","noop","useIntersectionObserver","onChange","_a","_b","root","rootMargin","threshold","disabled","observingRef","instanceRef","handleChange","event","unobserve","current","target","observe","observer","memoizedThreshold","undefined","rootOption","document","querySelector","obs","setRef","node","isNewNode"],"sources":["C:/Users/oyeti/Documents/GitHub/HNG_Stage-Three/node_modules/react-progressive-graceful-image/node_modules/@researchgate/react-intersection-observer/lib/es/hook.js"],"sourcesContent":["import { useRef, useCallback, useMemo } from 'react';\nimport { createObserver, observeElement, unobserveElement } from './observer';\nimport { thresholdCacheKey } from './utils';\nvar noop = function () { };\n/**\n * useIntersectionObserver hook that has almost the same api as <Observer />\n *\n * @param {ChangeHandler} onChange Function that will be invoked whenever the intersection value for this element changes.\n * @param {Options} options Option to customize instersction observer instance or disable it\n *\n * @example\n * const App = () => {\n *   const onChange = ({ isIntersecting }) => console.log({ isIntersecting })\n *   const ref = useIntersectionObserver(onChange)\n *\n *   return <div ref={ref} />\n * }\n */\nexport var useIntersectionObserver = function (\n/**\n * Function that will be invoked whenever the intersection value for this element changes.\n */\nonChange, _a) {\n    var _b = _a === void 0 ? {} : _a, root = _b.root, rootMargin = _b.rootMargin, threshold = _b.threshold, disabled = _b.disabled;\n    var observingRef = useRef(false);\n    var instanceRef = useRef({\n        // unobserve function needs an instance and instance.handleChange needs an unobserve to be caught by closure.\n        // So it's essentially a circular reference that's resolved by assigning handleChange later\n        handleChange: function (event) {\n            /* istanbul ignore next line */\n            onChange(event, noop);\n        },\n    });\n    var unobserve = useCallback(function () {\n        if (instanceRef.current.target && observingRef.current) {\n            unobserveElement(instanceRef.current, instanceRef.current.target);\n            observingRef.current = false;\n        }\n    }, []);\n    instanceRef.current.handleChange = function handleChange(event) {\n        /* istanbul ignore next line */\n        onChange(event, unobserve);\n    };\n    var observe = function () {\n        if (instanceRef.current.observer &&\n            instanceRef.current.target &&\n            !observingRef.current) {\n            observeElement(instanceRef.current);\n            observingRef.current = true;\n        }\n    };\n    var memoizedThreshold = useMemo(function () { return threshold; }, [\n        thresholdCacheKey(threshold),\n    ]);\n    var observer = useMemo(function () {\n        if (disabled) {\n            unobserve();\n            instanceRef.current.observer = undefined;\n            return undefined;\n        }\n        var rootOption = typeof root === 'string' ? document.querySelector(root) : root;\n        var obs = createObserver({\n            root: rootOption,\n            rootMargin: rootMargin,\n            threshold: memoizedThreshold,\n        });\n        instanceRef.current.observer = obs;\n        unobserve();\n        observe();\n        return obs;\n    }, [root, rootMargin, memoizedThreshold, disabled]);\n    var setRef = useCallback(function (node) {\n        var isNewNode = node != null && instanceRef.current.target !== node;\n        if (!observer) {\n            unobserve();\n        }\n        if (isNewNode) {\n            unobserve();\n            instanceRef.current.target = node;\n            observe();\n        }\n        if (!node) {\n            unobserve();\n            instanceRef.current.target = undefined;\n        }\n    }, [observer]);\n    return [setRef, unobserve];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}