{"ast":null,"code":"import _classCallCheck from \"C:/Users/oyeti/Documents/GitHub/HNG_Stage-Three/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/oyeti/Documents/GitHub/HNG_Stage-Three/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"C:/Users/oyeti/Documents/GitHub/HNG_Stage-Three/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _eventNames;\nimport { invariant } from '@react-dnd/invariant';\nimport { ListenerType } from './interfaces.js';\nimport { OptionsReader } from './OptionsReader.js';\nimport { distance, inAngleRanges } from './utils/math.js';\nimport { getEventClientOffset, getNodeClientOffset } from './utils/offsets.js';\nimport { eventShouldEndDrag, eventShouldStartDrag, isTouchEvent } from './utils/predicates.js';\nimport { supportsPassive } from './utils/supportsPassive.js';\nvar eventNames = (_eventNames = {}, _defineProperty(_eventNames, ListenerType.mouse, {\n  start: 'mousedown',\n  move: 'mousemove',\n  end: 'mouseup',\n  contextmenu: 'contextmenu'\n}), _defineProperty(_eventNames, ListenerType.touch, {\n  start: 'touchstart',\n  move: 'touchmove',\n  end: 'touchend'\n}), _defineProperty(_eventNames, ListenerType.keyboard, {\n  keydown: 'keydown'\n}), _eventNames);\nexport var TouchBackendImpl = /*#__PURE__*/function () {\n  function TouchBackendImpl(manager, context, options) {\n    var _this = this;\n    _classCallCheck(this, TouchBackendImpl);\n    this.getSourceClientOffset = function (sourceId) {\n      var element = _this.sourceNodes.get(sourceId);\n      return element && getNodeClientOffset(element);\n    };\n    this.handleTopMoveStartCapture = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n      _this.moveStartSourceIds = [];\n    };\n    this.handleMoveStart = function (sourceId) {\n      // Just because we received an event doesn't necessarily mean we need to collect drag sources.\n      // We only collect start collecting drag sources on touch and left mouse events.\n      if (Array.isArray(_this.moveStartSourceIds)) {\n        _this.moveStartSourceIds.unshift(sourceId);\n      }\n    };\n    this.handleTopMoveStart = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n      // Don't prematurely preventDefault() here since it might:\n      // 1. Mess up scrolling\n      // 2. Mess up long tap (which brings up context menu)\n      // 3. If there's an anchor link as a child, tap won't be triggered on link\n      var clientOffset = getEventClientOffset(e);\n      if (clientOffset) {\n        if (isTouchEvent(e)) {\n          _this.lastTargetTouchFallback = e.targetTouches[0];\n        }\n        _this._mouseClientOffset = clientOffset;\n      }\n      _this.waitingForDelay = false;\n    };\n    this.handleTopMoveStartDelay = function (e) {\n      if (!eventShouldStartDrag(e)) {\n        return;\n      }\n      var delay = e.type === eventNames.touch.start ? _this.options.delayTouchStart : _this.options.delayMouseStart;\n      _this.timeout = setTimeout(_this.handleTopMoveStart.bind(_this, e), delay);\n      _this.waitingForDelay = true;\n    };\n    this.handleTopMoveCapture = function () {\n      _this.dragOverTargetIds = [];\n    };\n    this.handleMove = function (_evt, targetId) {\n      if (_this.dragOverTargetIds) {\n        _this.dragOverTargetIds.unshift(targetId);\n      }\n    };\n    this.handleTopMove = function (e1) {\n      if (_this.timeout) {\n        clearTimeout(_this.timeout);\n      }\n      if (!_this.document || _this.waitingForDelay) {\n        return;\n      }\n      var moveStartSourceIds = _this.moveStartSourceIds,\n        dragOverTargetIds = _this.dragOverTargetIds;\n      var enableHoverOutsideTarget = _this.options.enableHoverOutsideTarget;\n      var clientOffset = getEventClientOffset(e1, _this.lastTargetTouchFallback);\n      if (!clientOffset) {\n        return;\n      }\n      // If the touch move started as a scroll, or is is between the scroll angles\n      if (_this._isScrolling || !_this.monitor.isDragging() && inAngleRanges(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y, _this.options.scrollAngleRanges)) {\n        _this._isScrolling = true;\n        return;\n      }\n      // If we're not dragging and we've moved a little, that counts as a drag start\n      if (!_this.monitor.isDragging() &&\n      // eslint-disable-next-line no-prototype-builtins\n      _this._mouseClientOffset.hasOwnProperty('x') && moveStartSourceIds && distance(_this._mouseClientOffset.x || 0, _this._mouseClientOffset.y || 0, clientOffset.x, clientOffset.y) > (_this.options.touchSlop ? _this.options.touchSlop : 0)) {\n        _this.moveStartSourceIds = undefined;\n        _this.actions.beginDrag(moveStartSourceIds, {\n          clientOffset: _this._mouseClientOffset,\n          getSourceClientOffset: _this.getSourceClientOffset,\n          publishSource: false\n        });\n      }\n      if (!_this.monitor.isDragging()) {\n        return;\n      }\n      var sourceNode = _this.sourceNodes.get(_this.monitor.getSourceId());\n      _this.installSourceNodeRemovalObserver(sourceNode);\n      _this.actions.publishDragSource();\n      if (e1.cancelable) e1.preventDefault();\n      // Get the node elements of the hovered DropTargets\n      var dragOverTargetNodes = (dragOverTargetIds || []).map(function (key) {\n        return _this.targetNodes.get(key);\n      }).filter(function (e) {\n        return !!e;\n      });\n      // Get the a ordered list of nodes that are touched by\n      var elementsAtPoint = _this.options.getDropTargetElementsAtPoint ? _this.options.getDropTargetElementsAtPoint(clientOffset.x, clientOffset.y, dragOverTargetNodes) : _this.document.elementsFromPoint(clientOffset.x, clientOffset.y);\n      // Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n      var elementsAtPointExtended = [];\n      for (var nodeId in elementsAtPoint) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (!elementsAtPoint.hasOwnProperty(nodeId)) {\n          continue;\n        }\n        var currentNode = elementsAtPoint[nodeId];\n        if (currentNode != null) {\n          elementsAtPointExtended.push(currentNode);\n        }\n        while (currentNode) {\n          currentNode = currentNode.parentElement;\n          if (currentNode && elementsAtPointExtended.indexOf(currentNode) === -1) {\n            elementsAtPointExtended.push(currentNode);\n          }\n        }\n      }\n      var orderedDragOverTargetIds = elementsAtPointExtended // Filter off nodes that arent a hovered DropTargets nodes\n      .filter(function (node) {\n        return dragOverTargetNodes.indexOf(node) > -1;\n      }) // Map back the nodes elements to targetIds\n      .map(function (node) {\n        return _this._getDropTargetId(node);\n      }) // Filter off possible null rows\n      .filter(function (node) {\n        return !!node;\n      }).filter(function (id, index, ids) {\n        return ids.indexOf(id) === index;\n      });\n      // Invoke hover for drop targets when source node is still over and pointer is outside\n      if (enableHoverOutsideTarget) {\n        for (var targetId in _this.targetNodes) {\n          var targetNode = _this.targetNodes.get(targetId);\n          if (sourceNode && targetNode && targetNode.contains(sourceNode) && orderedDragOverTargetIds.indexOf(targetId) === -1) {\n            orderedDragOverTargetIds.unshift(targetId);\n            break;\n          }\n        }\n      }\n      // Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n      orderedDragOverTargetIds.reverse();\n      _this.actions.hover(orderedDragOverTargetIds, {\n        clientOffset: clientOffset\n      });\n    };\n    /**\n    *\n    * visible for testing\n    */\n    this._getDropTargetId = function (node) {\n      var keys = _this.targetNodes.keys();\n      var next = keys.next();\n      while (next.done === false) {\n        var targetId = next.value;\n        if (node === _this.targetNodes.get(targetId)) {\n          return targetId;\n        } else {\n          next = keys.next();\n        }\n      }\n      return undefined;\n    };\n    this.handleTopMoveEndCapture = function (e) {\n      _this._isScrolling = false;\n      _this.lastTargetTouchFallback = undefined;\n      if (!eventShouldEndDrag(e)) {\n        return;\n      }\n      if (!_this.monitor.isDragging() || _this.monitor.didDrop()) {\n        _this.moveStartSourceIds = undefined;\n        return;\n      }\n      if (e.cancelable) e.preventDefault();\n      _this._mouseClientOffset = {};\n      _this.uninstallSourceNodeRemovalObserver();\n      _this.actions.drop();\n      _this.actions.endDrag();\n    };\n    this.handleCancelOnEscape = function (e) {\n      if (e.key === 'Escape' && _this.monitor.isDragging()) {\n        _this._mouseClientOffset = {};\n        _this.uninstallSourceNodeRemovalObserver();\n        _this.actions.endDrag();\n      }\n    };\n    this.options = new OptionsReader(options, context);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.sourceNodes = new Map();\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.targetNodes = new Map();\n    this.listenerTypes = [];\n    this._mouseClientOffset = {};\n    this._isScrolling = false;\n    if (this.options.enableMouseEvents) {\n      this.listenerTypes.push(ListenerType.mouse);\n    }\n    if (this.options.enableTouchEvents) {\n      this.listenerTypes.push(ListenerType.touch);\n    }\n    if (this.options.enableKeyboardEvents) {\n      this.listenerTypes.push(ListenerType.keyboard);\n    }\n  }\n  _createClass(TouchBackendImpl, [{\n    key: \"profile\",\n    value:\n    /**\n    * Generate profiling statistics for the HTML5Backend.\n    */\n    function profile() {\n      var ref;\n      return {\n        sourceNodes: this.sourceNodes.size,\n        sourcePreviewNodes: this.sourcePreviewNodes.size,\n        sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n        targetNodes: this.targetNodes.size,\n        dragOverTargetIds: ((ref = this.dragOverTargetIds) === null || ref === void 0 ? void 0 : ref.length) || 0\n      };\n    }\n    // public for test\n  }, {\n    key: \"document\",\n    get: function get() {\n      return this.options.document;\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var root = this.options.rootElement;\n      if (!root) {\n        return;\n      }\n      invariant(!TouchBackendImpl.isSetUp, 'Cannot have two Touch backends at the same time.');\n      TouchBackendImpl.isSetUp = true;\n      this.addEventListener(root, 'start', this.getTopMoveStartHandler());\n      this.addEventListener(root, 'start', this.handleTopMoveStartCapture, true);\n      this.addEventListener(root, 'move', this.handleTopMove);\n      this.addEventListener(root, 'move', this.handleTopMoveCapture, true);\n      this.addEventListener(root, 'end', this.handleTopMoveEndCapture, true);\n      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n        this.addEventListener(root, 'contextmenu', this.handleTopMoveEndCapture);\n      }\n      if (this.options.enableKeyboardEvents) {\n        this.addEventListener(root, 'keydown', this.handleCancelOnEscape, true);\n      }\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      var root = this.options.rootElement;\n      if (!root) {\n        return;\n      }\n      TouchBackendImpl.isSetUp = false;\n      this._mouseClientOffset = {};\n      this.removeEventListener(root, 'start', this.handleTopMoveStartCapture, true);\n      this.removeEventListener(root, 'start', this.handleTopMoveStart);\n      this.removeEventListener(root, 'move', this.handleTopMoveCapture, true);\n      this.removeEventListener(root, 'move', this.handleTopMove);\n      this.removeEventListener(root, 'end', this.handleTopMoveEndCapture, true);\n      if (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n        this.removeEventListener(root, 'contextmenu', this.handleTopMoveEndCapture);\n      }\n      if (this.options.enableKeyboardEvents) {\n        this.removeEventListener(root, 'keydown', this.handleCancelOnEscape, true);\n      }\n      this.uninstallSourceNodeRemovalObserver();\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(subject, event, handler) {\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var options = supportsPassive ? {\n        capture: capture,\n        passive: false\n      } : capture;\n      this.listenerTypes.forEach(function (listenerType) {\n        var evt = eventNames[listenerType][event];\n        if (evt) {\n          subject.addEventListener(evt, handler, options);\n        }\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(subject, event, handler) {\n      var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var options = supportsPassive ? {\n        capture: capture,\n        passive: false\n      } : capture;\n      this.listenerTypes.forEach(function (listenerType) {\n        var evt = eventNames[listenerType][event];\n        if (evt) {\n          subject.removeEventListener(evt, handler, options);\n        }\n      });\n    }\n  }, {\n    key: \"connectDragSource\",\n    value: function connectDragSource(sourceId, node) {\n      var _this2 = this;\n      var handleMoveStart = this.handleMoveStart.bind(this, sourceId);\n      this.sourceNodes.set(sourceId, node);\n      this.addEventListener(node, 'start', handleMoveStart);\n      return function () {\n        _this2.sourceNodes.delete(sourceId);\n        _this2.removeEventListener(node, 'start', handleMoveStart);\n      };\n    }\n  }, {\n    key: \"connectDragPreview\",\n    value: function connectDragPreview(sourceId, node, options) {\n      var _this3 = this;\n      this.sourcePreviewNodeOptions.set(sourceId, options);\n      this.sourcePreviewNodes.set(sourceId, node);\n      return function () {\n        _this3.sourcePreviewNodes.delete(sourceId);\n        _this3.sourcePreviewNodeOptions.delete(sourceId);\n      };\n    }\n  }, {\n    key: \"connectDropTarget\",\n    value: function connectDropTarget(targetId, node) {\n      var _this4 = this;\n      var root = this.options.rootElement;\n      if (!this.document || !root) {\n        return function () {\n          /* noop */};\n      }\n      var handleMove = function handleMove(e) {\n        if (!_this4.document || !root || !_this4.monitor.isDragging()) {\n          return;\n        }\n        var coords;\n        /**\n        * Grab the coordinates for the current mouse/touch position\n        */\n        switch (e.type) {\n          case eventNames.mouse.move:\n            coords = {\n              x: e.clientX,\n              y: e.clientY\n            };\n            break;\n          case eventNames.touch.move:\n            var ref, ref1;\n            coords = {\n              x: ((ref = e.touches[0]) === null || ref === void 0 ? void 0 : ref.clientX) || 0,\n              y: ((ref1 = e.touches[0]) === null || ref1 === void 0 ? void 0 : ref1.clientY) || 0\n            };\n            break;\n        }\n        /**\n        * Use the coordinates to grab the element the drag ended on.\n        * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n        */\n        var droppedOn = coords != null ? _this4.document.elementFromPoint(coords.x, coords.y) : undefined;\n        var childMatch = droppedOn && node.contains(droppedOn);\n        if (droppedOn === node || childMatch) {\n          return _this4.handleMove(e, targetId);\n        }\n      };\n      /**\n      * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n      */\n      this.addEventListener(this.document.body, 'move', handleMove);\n      this.targetNodes.set(targetId, node);\n      return function () {\n        if (_this4.document) {\n          _this4.targetNodes.delete(targetId);\n          _this4.removeEventListener(_this4.document.body, 'move', handleMove);\n        }\n      };\n    }\n  }, {\n    key: \"getTopMoveStartHandler\",\n    value: function getTopMoveStartHandler() {\n      if (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n        return this.handleTopMoveStart;\n      }\n      return this.handleTopMoveStartDelay;\n    }\n  }, {\n    key: \"installSourceNodeRemovalObserver\",\n    value: function installSourceNodeRemovalObserver(node) {\n      var _this5 = this;\n      this.uninstallSourceNodeRemovalObserver();\n      this.draggedSourceNode = node;\n      this.draggedSourceNodeRemovalObserver = new MutationObserver(function () {\n        if (node && !node.parentElement) {\n          _this5.resurrectSourceNode();\n          _this5.uninstallSourceNodeRemovalObserver();\n        }\n      });\n      if (!node || !node.parentElement) {\n        return;\n      }\n      this.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n        childList: true\n      });\n    }\n  }, {\n    key: \"resurrectSourceNode\",\n    value: function resurrectSourceNode() {\n      if (this.document && this.draggedSourceNode) {\n        this.draggedSourceNode.style.display = 'none';\n        this.draggedSourceNode.removeAttribute('data-reactid');\n        this.document.body.appendChild(this.draggedSourceNode);\n      }\n    }\n  }, {\n    key: \"uninstallSourceNodeRemovalObserver\",\n    value: function uninstallSourceNodeRemovalObserver() {\n      if (this.draggedSourceNodeRemovalObserver) {\n        this.draggedSourceNodeRemovalObserver.disconnect();\n      }\n      this.draggedSourceNodeRemovalObserver = undefined;\n      this.draggedSourceNode = undefined;\n    }\n  }]);\n  return TouchBackendImpl;\n}();","map":{"version":3,"names":["invariant","ListenerType","OptionsReader","distance","inAngleRanges","getEventClientOffset","getNodeClientOffset","eventShouldEndDrag","eventShouldStartDrag","isTouchEvent","supportsPassive","eventNames","_eventNames","_defineProperty","mouse","start","move","end","contextmenu","touch","keyboard","keydown","TouchBackendImpl","manager","context","options","_this","_classCallCheck","getSourceClientOffset","sourceId","element","sourceNodes","get","handleTopMoveStartCapture","e","moveStartSourceIds","handleMoveStart","Array","isArray","unshift","handleTopMoveStart","clientOffset","lastTargetTouchFallback","targetTouches","_mouseClientOffset","waitingForDelay","handleTopMoveStartDelay","delay","type","delayTouchStart","delayMouseStart","timeout","setTimeout","bind","handleTopMoveCapture","dragOverTargetIds","handleMove","_evt","targetId","handleTopMove","e1","clearTimeout","document","enableHoverOutsideTarget","_isScrolling","monitor","isDragging","x","y","scrollAngleRanges","hasOwnProperty","touchSlop","undefined","actions","beginDrag","publishSource","sourceNode","getSourceId","installSourceNodeRemovalObserver","publishDragSource","cancelable","preventDefault","dragOverTargetNodes","map","key","targetNodes","filter","elementsAtPoint","getDropTargetElementsAtPoint","elementsFromPoint","elementsAtPointExtended","nodeId","currentNode","push","parentElement","indexOf","orderedDragOverTargetIds","node","_getDropTargetId","id","index","ids","targetNode","contains","reverse","hover","keys","next","done","value","handleTopMoveEndCapture","didDrop","uninstallSourceNodeRemovalObserver","drop","endDrag","handleCancelOnEscape","getActions","getMonitor","Map","sourcePreviewNodes","sourcePreviewNodeOptions","listenerTypes","enableMouseEvents","enableTouchEvents","enableKeyboardEvents","_createClass","profile","ref","size","length","setup","root","rootElement","isSetUp","addEventListener","getTopMoveStartHandler","ignoreContextMenu","teardown","removeEventListener","subject","event","handler","capture","arguments","passive","forEach","listenerType","evt","connectDragSource","_this2","set","delete","connectDragPreview","_this3","connectDropTarget","_this4","coords","clientX","clientY","ref1","touches","droppedOn","elementFromPoint","childMatch","body","_this5","draggedSourceNode","draggedSourceNodeRemovalObserver","MutationObserver","resurrectSourceNode","observe","childList","style","display","removeAttribute","appendChild","disconnect"],"sources":["C:\\Users\\oyeti\\Documents\\GitHub\\HNG_Stage-Three\\node_modules\\react-dnd-touch-backend\\src\\TouchBackendImpl.ts"],"sourcesContent":["import { invariant } from '@react-dnd/invariant'\nimport type {\n\tBackend,\n\tDragDropActions,\n\tDragDropManager,\n\tDragDropMonitor,\n\tIdentifier,\n\tUnsubscribe,\n\tXYCoord,\n} from 'dnd-core'\n\nimport type {\n\tEventName,\n\tTouchBackendContext,\n\tTouchBackendOptions,\n} from './interfaces.js'\nimport { ListenerType } from './interfaces.js'\nimport { OptionsReader } from './OptionsReader.js'\nimport { distance, inAngleRanges } from './utils/math.js'\nimport { getEventClientOffset, getNodeClientOffset } from './utils/offsets.js'\nimport {\n\teventShouldEndDrag,\n\teventShouldStartDrag,\n\tisTouchEvent,\n} from './utils/predicates.js'\nimport { supportsPassive } from './utils/supportsPassive.js'\n\nconst eventNames: Record<ListenerType, EventName> = {\n\t[ListenerType.mouse]: {\n\t\tstart: 'mousedown',\n\t\tmove: 'mousemove',\n\t\tend: 'mouseup',\n\t\tcontextmenu: 'contextmenu',\n\t},\n\t[ListenerType.touch]: {\n\t\tstart: 'touchstart',\n\t\tmove: 'touchmove',\n\t\tend: 'touchend',\n\t},\n\t[ListenerType.keyboard]: {\n\t\tkeydown: 'keydown',\n\t},\n}\n\nexport class TouchBackendImpl implements Backend {\n\tprivate options: OptionsReader\n\n\t// React-DnD Dependencies\n\tprivate actions: DragDropActions\n\tprivate monitor: DragDropMonitor\n\n\t// Internal State\n\tprivate static isSetUp: boolean\n\tpublic sourceNodes: Map<Identifier, HTMLElement>\n\tpublic sourcePreviewNodes: Map<string, HTMLElement>\n\tpublic sourcePreviewNodeOptions: Map<string, any>\n\tpublic targetNodes: Map<string, HTMLElement>\n\tprivate _mouseClientOffset: Partial<XYCoord>\n\tprivate _isScrolling: boolean\n\tprivate listenerTypes: ListenerType[]\n\tprivate moveStartSourceIds: string[] | undefined\n\tprivate waitingForDelay: boolean | undefined\n\tprivate timeout: ReturnType<typeof setTimeout> | undefined\n\tprivate dragOverTargetIds: string[] | undefined\n\tprivate draggedSourceNode: HTMLElement | undefined\n\tprivate draggedSourceNodeRemovalObserver: MutationObserver | undefined\n\n\t// Patch for iOS 13, discussion over #1585\n\tprivate lastTargetTouchFallback: Touch | undefined\n\n\tpublic constructor(\n\t\tmanager: DragDropManager,\n\t\tcontext: TouchBackendContext,\n\t\toptions: Partial<TouchBackendOptions>,\n\t) {\n\t\tthis.options = new OptionsReader(options, context)\n\t\tthis.actions = manager.getActions()\n\t\tthis.monitor = manager.getMonitor()\n\n\t\tthis.sourceNodes = new Map()\n\t\tthis.sourcePreviewNodes = new Map()\n\t\tthis.sourcePreviewNodeOptions = new Map()\n\t\tthis.targetNodes = new Map()\n\t\tthis.listenerTypes = []\n\t\tthis._mouseClientOffset = {}\n\t\tthis._isScrolling = false\n\n\t\tif (this.options.enableMouseEvents) {\n\t\t\tthis.listenerTypes.push(ListenerType.mouse)\n\t\t}\n\n\t\tif (this.options.enableTouchEvents) {\n\t\t\tthis.listenerTypes.push(ListenerType.touch)\n\t\t}\n\n\t\tif (this.options.enableKeyboardEvents) {\n\t\t\tthis.listenerTypes.push(ListenerType.keyboard)\n\t\t}\n\t}\n\n\t/**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */\n\tpublic profile(): Record<string, number> {\n\t\treturn {\n\t\t\tsourceNodes: this.sourceNodes.size,\n\t\t\tsourcePreviewNodes: this.sourcePreviewNodes.size,\n\t\t\tsourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n\t\t\ttargetNodes: this.targetNodes.size,\n\t\t\tdragOverTargetIds: this.dragOverTargetIds?.length || 0,\n\t\t}\n\t}\n\n\t// public for test\n\tpublic get document(): Document | undefined {\n\t\treturn this.options.document\n\t}\n\n\tpublic setup(): void {\n\t\tconst root = this.options.rootElement\n\t\tif (!root) {\n\t\t\treturn\n\t\t}\n\n\t\tinvariant(\n\t\t\t!TouchBackendImpl.isSetUp,\n\t\t\t'Cannot have two Touch backends at the same time.',\n\t\t)\n\t\tTouchBackendImpl.isSetUp = true\n\n\t\tthis.addEventListener(root, 'start', this.getTopMoveStartHandler() as any)\n\t\tthis.addEventListener(\n\t\t\troot,\n\t\t\t'start',\n\t\t\tthis.handleTopMoveStartCapture as any,\n\t\t\ttrue,\n\t\t)\n\t\tthis.addEventListener(root, 'move', this.handleTopMove as any)\n\t\tthis.addEventListener(root, 'move', this.handleTopMoveCapture, true)\n\t\tthis.addEventListener(\n\t\t\troot,\n\t\t\t'end',\n\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\ttrue,\n\t\t)\n\n\t\tif (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n\t\t\tthis.addEventListener(\n\t\t\t\troot,\n\t\t\t\t'contextmenu',\n\t\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\t)\n\t\t}\n\n\t\tif (this.options.enableKeyboardEvents) {\n\t\t\tthis.addEventListener(\n\t\t\t\troot,\n\t\t\t\t'keydown',\n\t\t\t\tthis.handleCancelOnEscape as any,\n\t\t\t\ttrue,\n\t\t\t)\n\t\t}\n\t}\n\n\tpublic teardown(): void {\n\t\tconst root = this.options.rootElement\n\t\tif (!root) {\n\t\t\treturn\n\t\t}\n\n\t\tTouchBackendImpl.isSetUp = false\n\t\tthis._mouseClientOffset = {}\n\n\t\tthis.removeEventListener(\n\t\t\troot,\n\t\t\t'start',\n\t\t\tthis.handleTopMoveStartCapture as any,\n\t\t\ttrue,\n\t\t)\n\t\tthis.removeEventListener(root, 'start', this.handleTopMoveStart as any)\n\t\tthis.removeEventListener(root, 'move', this.handleTopMoveCapture, true)\n\t\tthis.removeEventListener(root, 'move', this.handleTopMove as any)\n\t\tthis.removeEventListener(\n\t\t\troot,\n\t\t\t'end',\n\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\ttrue,\n\t\t)\n\n\t\tif (this.options.enableMouseEvents && !this.options.ignoreContextMenu) {\n\t\t\tthis.removeEventListener(\n\t\t\t\troot,\n\t\t\t\t'contextmenu',\n\t\t\t\tthis.handleTopMoveEndCapture as any,\n\t\t\t)\n\t\t}\n\n\t\tif (this.options.enableKeyboardEvents) {\n\t\t\tthis.removeEventListener(\n\t\t\t\troot,\n\t\t\t\t'keydown',\n\t\t\t\tthis.handleCancelOnEscape as any,\n\t\t\t\ttrue,\n\t\t\t)\n\t\t}\n\n\t\tthis.uninstallSourceNodeRemovalObserver()\n\t}\n\n\tprivate addEventListener<K extends keyof EventName>(\n\t\tsubject: Node,\n\t\tevent: K,\n\t\thandler: (e: any) => void,\n\t\tcapture = false,\n\t) {\n\t\tconst options = supportsPassive ? { capture, passive: false } : capture\n\n\t\tthis.listenerTypes.forEach(function (listenerType) {\n\t\t\tconst evt = eventNames[listenerType][event]\n\n\t\t\tif (evt) {\n\t\t\t\tsubject.addEventListener(evt as any, handler as any, options)\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate removeEventListener<K extends keyof EventName>(\n\t\tsubject: Node,\n\t\tevent: K,\n\t\thandler: (e: any) => void,\n\t\tcapture = false,\n\t) {\n\t\tconst options = supportsPassive ? { capture, passive: false } : capture\n\n\t\tthis.listenerTypes.forEach(function (listenerType) {\n\t\t\tconst evt = eventNames[listenerType][event]\n\n\t\t\tif (evt) {\n\t\t\t\tsubject.removeEventListener(evt as any, handler as any, options)\n\t\t\t}\n\t\t})\n\t}\n\n\tpublic connectDragSource(sourceId: string, node: HTMLElement): Unsubscribe {\n\t\tconst handleMoveStart = this.handleMoveStart.bind(this, sourceId)\n\t\tthis.sourceNodes.set(sourceId, node)\n\n\t\tthis.addEventListener(node, 'start', handleMoveStart)\n\n\t\treturn (): void => {\n\t\t\tthis.sourceNodes.delete(sourceId)\n\t\t\tthis.removeEventListener(node, 'start', handleMoveStart)\n\t\t}\n\t}\n\n\tpublic connectDragPreview(\n\t\tsourceId: string,\n\t\tnode: HTMLElement,\n\t\toptions: unknown,\n\t): Unsubscribe {\n\t\tthis.sourcePreviewNodeOptions.set(sourceId, options)\n\t\tthis.sourcePreviewNodes.set(sourceId, node)\n\n\t\treturn (): void => {\n\t\t\tthis.sourcePreviewNodes.delete(sourceId)\n\t\t\tthis.sourcePreviewNodeOptions.delete(sourceId)\n\t\t}\n\t}\n\n\tpublic connectDropTarget(targetId: string, node: HTMLElement): Unsubscribe {\n\t\tconst root = this.options.rootElement\n\t\tif (!this.document || !root) {\n\t\t\treturn (): void => {\n\t\t\t\t/* noop */\n\t\t\t}\n\t\t}\n\n\t\tconst handleMove = (e: MouseEvent | TouchEvent) => {\n\t\t\tif (!this.document || !root || !this.monitor.isDragging()) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlet coords\n\n\t\t\t/**\n\t\t\t * Grab the coordinates for the current mouse/touch position\n\t\t\t */\n\t\t\tswitch (e.type) {\n\t\t\t\tcase eventNames.mouse.move:\n\t\t\t\t\tcoords = {\n\t\t\t\t\t\tx: (e as MouseEvent).clientX,\n\t\t\t\t\t\ty: (e as MouseEvent).clientY,\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase eventNames.touch.move:\n\t\t\t\t\tcoords = {\n\t\t\t\t\t\tx: (e as TouchEvent).touches[0]?.clientX || 0,\n\t\t\t\t\t\ty: (e as TouchEvent).touches[0]?.clientY || 0,\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Use the coordinates to grab the element the drag ended on.\n\t\t\t * If the element is the same as the target node (or any of it's children) then we have hit a drop target and can handle the move.\n\t\t\t */\n\t\t\tconst droppedOn =\n\t\t\t\tcoords != null\n\t\t\t\t\t? this.document.elementFromPoint(coords.x, coords.y)\n\t\t\t\t\t: undefined\n\t\t\tconst childMatch = droppedOn && node.contains(droppedOn)\n\n\t\t\tif (droppedOn === node || childMatch) {\n\t\t\t\treturn this.handleMove(e, targetId)\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Attaching the event listener to the body so that touchmove will work while dragging over multiple target elements.\n\t\t */\n\t\tthis.addEventListener(this.document.body, 'move', handleMove as any)\n\t\tthis.targetNodes.set(targetId, node)\n\n\t\treturn (): void => {\n\t\t\tif (this.document) {\n\t\t\t\tthis.targetNodes.delete(targetId)\n\t\t\t\tthis.removeEventListener(this.document.body, 'move', handleMove as any)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getSourceClientOffset = (sourceId: string): XYCoord | undefined => {\n\t\tconst element = this.sourceNodes.get(sourceId)\n\t\treturn element && getNodeClientOffset(element)\n\t}\n\n\tpublic handleTopMoveStartCapture = (e: Event): void => {\n\t\tif (!eventShouldStartDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.moveStartSourceIds = []\n\t}\n\n\tpublic handleMoveStart = (sourceId: string): void => {\n\t\t// Just because we received an event doesn't necessarily mean we need to collect drag sources.\n\t\t// We only collect start collecting drag sources on touch and left mouse events.\n\t\tif (Array.isArray(this.moveStartSourceIds)) {\n\t\t\tthis.moveStartSourceIds.unshift(sourceId)\n\t\t}\n\t}\n\n\tprivate getTopMoveStartHandler() {\n\t\tif (!this.options.delayTouchStart && !this.options.delayMouseStart) {\n\t\t\treturn this.handleTopMoveStart\n\t\t}\n\n\t\treturn this.handleTopMoveStartDelay\n\t}\n\n\tpublic handleTopMoveStart = (e: MouseEvent | TouchEvent): void => {\n\t\tif (!eventShouldStartDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\t// Don't prematurely preventDefault() here since it might:\n\t\t// 1. Mess up scrolling\n\t\t// 2. Mess up long tap (which brings up context menu)\n\t\t// 3. If there's an anchor link as a child, tap won't be triggered on link\n\n\t\tconst clientOffset = getEventClientOffset(e)\n\t\tif (clientOffset) {\n\t\t\tif (isTouchEvent(e)) {\n\t\t\t\tthis.lastTargetTouchFallback = e.targetTouches[0]\n\t\t\t}\n\t\t\tthis._mouseClientOffset = clientOffset\n\t\t}\n\t\tthis.waitingForDelay = false\n\t}\n\n\tpublic handleTopMoveStartDelay = (e: Event): void => {\n\t\tif (!eventShouldStartDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\tconst delay =\n\t\t\te.type === eventNames.touch.start\n\t\t\t\t? this.options.delayTouchStart\n\t\t\t\t: this.options.delayMouseStart\n\t\tthis.timeout = setTimeout(\n\t\t\tthis.handleTopMoveStart.bind(this, e as any),\n\t\t\tdelay,\n\t\t) as any as ReturnType<typeof setTimeout>\n\t\tthis.waitingForDelay = true\n\t}\n\n\tpublic handleTopMoveCapture = (): void => {\n\t\tthis.dragOverTargetIds = []\n\t}\n\n\tpublic handleMove = (\n\t\t_evt: MouseEvent | TouchEvent,\n\t\ttargetId: string,\n\t): void => {\n\t\tif (this.dragOverTargetIds) {\n\t\t\tthis.dragOverTargetIds.unshift(targetId)\n\t\t}\n\t}\n\n\tpublic handleTopMove = (e: TouchEvent | MouseEvent): void => {\n\t\tif (this.timeout) {\n\t\t\tclearTimeout(this.timeout)\n\t\t}\n\t\tif (!this.document || this.waitingForDelay) {\n\t\t\treturn\n\t\t}\n\t\tconst { moveStartSourceIds, dragOverTargetIds } = this\n\t\tconst enableHoverOutsideTarget = this.options.enableHoverOutsideTarget\n\n\t\tconst clientOffset = getEventClientOffset(e, this.lastTargetTouchFallback)\n\n\t\tif (!clientOffset) {\n\t\t\treturn\n\t\t}\n\n\t\t// If the touch move started as a scroll, or is is between the scroll angles\n\t\tif (\n\t\t\tthis._isScrolling ||\n\t\t\t(!this.monitor.isDragging() &&\n\t\t\t\tinAngleRanges(\n\t\t\t\t\tthis._mouseClientOffset.x || 0,\n\t\t\t\t\tthis._mouseClientOffset.y || 0,\n\t\t\t\t\tclientOffset.x,\n\t\t\t\t\tclientOffset.y,\n\t\t\t\t\tthis.options.scrollAngleRanges,\n\t\t\t\t))\n\t\t) {\n\t\t\tthis._isScrolling = true\n\t\t\treturn\n\t\t}\n\n\t\t// If we're not dragging and we've moved a little, that counts as a drag start\n\t\tif (\n\t\t\t!this.monitor.isDragging() &&\n\t\t\t// eslint-disable-next-line no-prototype-builtins\n\t\t\tthis._mouseClientOffset.hasOwnProperty('x') &&\n\t\t\tmoveStartSourceIds &&\n\t\t\tdistance(\n\t\t\t\tthis._mouseClientOffset.x || 0,\n\t\t\t\tthis._mouseClientOffset.y || 0,\n\t\t\t\tclientOffset.x,\n\t\t\t\tclientOffset.y,\n\t\t\t) > (this.options.touchSlop ? this.options.touchSlop : 0)\n\t\t) {\n\t\t\tthis.moveStartSourceIds = undefined\n\n\t\t\tthis.actions.beginDrag(moveStartSourceIds, {\n\t\t\t\tclientOffset: this._mouseClientOffset,\n\t\t\t\tgetSourceClientOffset: this.getSourceClientOffset,\n\t\t\t\tpublishSource: false,\n\t\t\t})\n\t\t}\n\n\t\tif (!this.monitor.isDragging()) {\n\t\t\treturn\n\t\t}\n\n\t\tconst sourceNode = this.sourceNodes.get(\n\t\t\tthis.monitor.getSourceId() as string,\n\t\t)\n\t\tthis.installSourceNodeRemovalObserver(sourceNode)\n\t\tthis.actions.publishDragSource()\n\n\t\tif (e.cancelable) e.preventDefault()\n\n\t\t// Get the node elements of the hovered DropTargets\n\t\tconst dragOverTargetNodes: HTMLElement[] = (dragOverTargetIds || [])\n\t\t\t.map((key) => this.targetNodes.get(key))\n\t\t\t.filter((e) => !!e) as HTMLElement[]\n\n\t\t// Get the a ordered list of nodes that are touched by\n\t\tconst elementsAtPoint = this.options.getDropTargetElementsAtPoint\n\t\t\t? this.options.getDropTargetElementsAtPoint(\n\t\t\t\t\tclientOffset.x,\n\t\t\t\t\tclientOffset.y,\n\t\t\t\t\tdragOverTargetNodes,\n\t\t\t  )\n\t\t\t: this.document.elementsFromPoint(clientOffset.x, clientOffset.y)\n\t\t// Extend list with parents that are not receiving elementsFromPoint events (size 0 elements and svg groups)\n\t\tconst elementsAtPointExtended: Element[] = []\n\t\tfor (const nodeId in elementsAtPoint) {\n\t\t\t// eslint-disable-next-line no-prototype-builtins\n\t\t\tif (!elementsAtPoint.hasOwnProperty(nodeId)) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlet currentNode: Element | undefined | null = elementsAtPoint[nodeId]\n\t\t\tif (currentNode != null) {\n\t\t\t\telementsAtPointExtended.push(currentNode)\n\t\t\t}\n\t\t\twhile (currentNode) {\n\t\t\t\tcurrentNode = currentNode.parentElement\n\t\t\t\tif (\n\t\t\t\t\tcurrentNode &&\n\t\t\t\t\telementsAtPointExtended.indexOf(currentNode) === -1\n\t\t\t\t) {\n\t\t\t\t\telementsAtPointExtended.push(currentNode)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst orderedDragOverTargetIds: string[] = elementsAtPointExtended\n\t\t\t// Filter off nodes that arent a hovered DropTargets nodes\n\t\t\t.filter((node) => dragOverTargetNodes.indexOf(node as HTMLElement) > -1)\n\t\t\t// Map back the nodes elements to targetIds\n\t\t\t.map((node) => this._getDropTargetId(node))\n\t\t\t// Filter off possible null rows\n\t\t\t.filter((node) => !!node)\n\t\t\t.filter((id, index, ids) => ids.indexOf(id) === index) as string[]\n\n\t\t// Invoke hover for drop targets when source node is still over and pointer is outside\n\t\tif (enableHoverOutsideTarget) {\n\t\t\tfor (const targetId in this.targetNodes) {\n\t\t\t\tconst targetNode = this.targetNodes.get(targetId)\n\t\t\t\tif (\n\t\t\t\t\tsourceNode &&\n\t\t\t\t\ttargetNode &&\n\t\t\t\t\ttargetNode.contains(sourceNode) &&\n\t\t\t\t\torderedDragOverTargetIds.indexOf(targetId) === -1\n\t\t\t\t) {\n\t\t\t\t\torderedDragOverTargetIds.unshift(targetId)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reverse order because dnd-core reverse it before calling the DropTarget drop methods\n\t\torderedDragOverTargetIds.reverse()\n\n\t\tthis.actions.hover(orderedDragOverTargetIds, {\n\t\t\tclientOffset: clientOffset,\n\t\t})\n\t}\n\n\t/**\n\t *\n\t * visible for testing\n\t */\n\tpublic _getDropTargetId = (node: Element): Identifier | undefined => {\n\t\tconst keys = this.targetNodes.keys()\n\t\tlet next = keys.next()\n\t\twhile (next.done === false) {\n\t\t\tconst targetId = next.value\n\t\t\tif (node === this.targetNodes.get(targetId)) {\n\t\t\t\treturn targetId\n\t\t\t} else {\n\t\t\t\tnext = keys.next()\n\t\t\t}\n\t\t}\n\t\treturn undefined\n\t}\n\n\tpublic handleTopMoveEndCapture = (e: Event): void => {\n\t\tthis._isScrolling = false\n\t\tthis.lastTargetTouchFallback = undefined\n\n\t\tif (!eventShouldEndDrag(e as MouseEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (!this.monitor.isDragging() || this.monitor.didDrop()) {\n\t\t\tthis.moveStartSourceIds = undefined\n\t\t\treturn\n\t\t}\n\n\t\tif (e.cancelable) e.preventDefault()\n\n\t\tthis._mouseClientOffset = {}\n\n\t\tthis.uninstallSourceNodeRemovalObserver()\n\t\tthis.actions.drop()\n\t\tthis.actions.endDrag()\n\t}\n\n\tpublic handleCancelOnEscape = (e: KeyboardEvent): void => {\n\t\tif (e.key === 'Escape' && this.monitor.isDragging()) {\n\t\t\tthis._mouseClientOffset = {}\n\n\t\t\tthis.uninstallSourceNodeRemovalObserver()\n\t\t\tthis.actions.endDrag()\n\t\t}\n\t}\n\n\tprivate installSourceNodeRemovalObserver(node: HTMLElement | undefined) {\n\t\tthis.uninstallSourceNodeRemovalObserver()\n\n\t\tthis.draggedSourceNode = node\n\t\tthis.draggedSourceNodeRemovalObserver = new MutationObserver(() => {\n\t\t\tif (node && !node.parentElement) {\n\t\t\t\tthis.resurrectSourceNode()\n\t\t\t\tthis.uninstallSourceNodeRemovalObserver()\n\t\t\t}\n\t\t})\n\n\t\tif (!node || !node.parentElement) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.draggedSourceNodeRemovalObserver.observe(node.parentElement, {\n\t\t\tchildList: true,\n\t\t})\n\t}\n\n\tprivate resurrectSourceNode() {\n\t\tif (this.document && this.draggedSourceNode) {\n\t\t\tthis.draggedSourceNode.style.display = 'none'\n\t\t\tthis.draggedSourceNode.removeAttribute('data-reactid')\n\t\t\tthis.document.body.appendChild(this.draggedSourceNode)\n\t\t}\n\t}\n\n\tprivate uninstallSourceNodeRemovalObserver() {\n\t\tif (this.draggedSourceNodeRemovalObserver) {\n\t\t\tthis.draggedSourceNodeRemovalObserver.disconnect()\n\t\t}\n\n\t\tthis.draggedSourceNodeRemovalObserver = undefined\n\t\tthis.draggedSourceNode = undefined\n\t}\n}\n"],"mappings":";;;;AAAA,SAASA,SAAS,QAAQ,sBAAsB;AAgBhD,SAASC,YAAY,QAAQ,iBAAiB;AAC9C,SAASC,aAAa,QAAQ,oBAAoB;AAClD,SAASC,QAAQ,EAAEC,aAAa,QAAQ,iBAAiB;AACzD,SAASC,oBAAoB,EAAEC,mBAAmB,QAAQ,oBAAoB;AAC9E,SACCC,kBAAkB,EAClBC,oBAAoB,EACpBC,YAAY,QACN,uBAAuB;AAC9B,SAASC,eAAe,QAAQ,4BAA4B;AAE5D,IAAMC,UAAU,IAAAC,WAAA,OAAAC,eAAA,CAAAD,WAAA,EACdX,YAAY,CAACa,KAAK,EAAG;EACrBC,KAAK,EAAE,WAAW;EAClBC,IAAI,EAAE,WAAW;EACjBC,GAAG,EAAE,SAAS;EACdC,WAAW,EAAE;CACb,GAAAL,eAAA,CAAAD,WAAA,EACAX,YAAY,CAACkB,KAAK,EAAG;EACrBJ,KAAK,EAAE,YAAY;EACnBC,IAAI,EAAE,WAAW;EACjBC,GAAG,EAAE;CACL,GAAAJ,eAAA,CAAAD,WAAA,EACAX,YAAY,CAACmB,QAAQ,EAAG;EACxBC,OAAO,EAAE;CACT,GAAAT,WAAA,CACD;AAED,WAAaU,gBAAgB;EA0B5B,SAAAA,iBACCC,OAAwB,EACxBC,OAA4B,EAC5BC,OAAqC,EACpC;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAL,gBAAA;IAkQF,KAAQM,qBAAqB,GAAG,UAACC,QAAgB,EAA0B;MAC1E,IAAMC,OAAO,GAAGJ,KAAI,CAACK,WAAW,CAACC,GAAG,CAACH,QAAQ,CAAC;MAC9C,OAAOC,OAAO,IAAIxB,mBAAmB,CAACwB,OAAO,CAAC;KAC9C;IAED,KAAOG,yBAAyB,GAAG,UAACC,CAAQ,EAAW;MACtD,IAAI,CAAC1B,oBAAoB,CAAC0B,CAAC,CAAe,EAAE;QAC3C;;MAGDR,KAAI,CAACS,kBAAkB,GAAG,EAAE;KAC5B;IAED,KAAOC,eAAe,GAAG,UAACP,QAAgB,EAAW;MACpD;MACA;MACA,IAAIQ,KAAK,CAACC,OAAO,CAACZ,KAAI,CAACS,kBAAkB,CAAC,EAAE;QAC3CT,KAAI,CAACS,kBAAkB,CAACI,OAAO,CAACV,QAAQ,CAAC;;KAE1C;IAUD,KAAOW,kBAAkB,GAAG,UAACN,CAA0B,EAAW;MACjE,IAAI,CAAC1B,oBAAoB,CAAC0B,CAAC,CAAe,EAAE;QAC3C;;MAGD;MACA;MACA;MACA;MAEA,IAAMO,YAAY,GAAGpC,oBAAoB,CAAC6B,CAAC,CAAC;MAC5C,IAAIO,YAAY,EAAE;QACjB,IAAIhC,YAAY,CAACyB,CAAC,CAAC,EAAE;UACpBR,KAAI,CAACgB,uBAAuB,GAAGR,CAAC,CAACS,aAAa,CAAC,CAAC,CAAC;;QAElDjB,KAAI,CAACkB,kBAAkB,GAAGH,YAAY;;MAEvCf,KAAI,CAACmB,eAAe,GAAG,KAAK;KAC5B;IAED,KAAOC,uBAAuB,GAAG,UAACZ,CAAQ,EAAW;MACpD,IAAI,CAAC1B,oBAAoB,CAAC0B,CAAC,CAAe,EAAE;QAC3C;;MAGD,IAAMa,KAAK,GACVb,CAAC,CAACc,IAAI,KAAKrC,UAAU,CAACQ,KAAK,CAACJ,KAAK,GAC9BW,KAAI,CAACD,OAAO,CAACwB,eAAe,GAC5BvB,KAAI,CAACD,OAAO,CAACyB,eAAe;MAChCxB,KAAI,CAACyB,OAAO,GAAGC,UAAU,CACxB1B,KAAI,CAACc,kBAAkB,CAACa,IAAI,CAAC3B,KAAI,EAAEQ,CAAC,CAAQ,EAC5Ca,KAAK,CACL;MACDrB,KAAI,CAACmB,eAAe,GAAG,IAAI;KAC3B;IAED,KAAOS,oBAAoB,GAAG,YAAY;MACzC5B,KAAI,CAAC6B,iBAAiB,GAAG,EAAE;KAC3B;IAED,KAAOC,UAAU,GAAG,UACnBC,IAA6B,EAC7BC,QAAgB,EACN;MACV,IAAIhC,KAAI,CAAC6B,iBAAiB,EAAE;QAC3B7B,KAAI,CAAC6B,iBAAiB,CAAChB,OAAO,CAACmB,QAAQ,CAAC;;KAEzC;IAED,KAAOC,aAAa,GAAG,UAACC,EAA0B,EAAW;MAC5D,IAAIlC,KAAI,CAACyB,OAAO,EAAE;QACjBU,YAAY,CAACnC,KAAI,CAACyB,OAAO,CAAC;;MAE3B,IAAI,CAACzB,KAAI,CAACoC,QAAQ,IAAIpC,KAAI,CAACmB,eAAe,EAAE;QAC3C;;MAED,IAAQV,kBAAkB,GAAwBT,KAAI,CAA9CS,kBAAkB;QAAEoB,iBAAiB,GAAK7B,KAAI,CAA1B6B,iBAAiB;MAC7C,IAAMQ,wBAAwB,GAAGrC,KAAI,CAACD,OAAO,CAACsC,wBAAwB;MAEtE,IAAMtB,YAAY,GAAGpC,oBAAoB,CAACuD,EAAC,EAAElC,KAAI,CAACgB,uBAAuB,CAAC;MAE1E,IAAI,CAACD,YAAY,EAAE;QAClB;;MAGD;MACA,IACCf,KAAI,CAACsC,YAAY,IAChB,CAACtC,KAAI,CAACuC,OAAO,CAACC,UAAU,EAAE,IAC1B9D,aAAa,CACZsB,KAAI,CAACkB,kBAAkB,CAACuB,CAAC,IAAI,CAAC,EAC9BzC,KAAI,CAACkB,kBAAkB,CAACwB,CAAC,IAAI,CAAC,EAC9B3B,YAAY,CAAC0B,CAAC,EACd1B,YAAY,CAAC2B,CAAC,EACd1C,KAAI,CAACD,OAAO,CAAC4C,iBAAiB,CAC9B,EACD;QACD3C,KAAI,CAACsC,YAAY,GAAG,IAAI;QACxB;;MAGD;MACA,IACC,CAACtC,KAAI,CAACuC,OAAO,CAACC,UAAU,EAAE;MAC1B;MACAxC,KAAI,CAACkB,kBAAkB,CAAC0B,cAAc,CAAC,GAAG,CAAC,IAC3CnC,kBAAkB,IAClBhC,QAAQ,CACPuB,KAAI,CAACkB,kBAAkB,CAACuB,CAAC,IAAI,CAAC,EAC9BzC,KAAI,CAACkB,kBAAkB,CAACwB,CAAC,IAAI,CAAC,EAC9B3B,YAAY,CAAC0B,CAAC,EACd1B,YAAY,CAAC2B,CAAC,CACd,IAAI1C,KAAI,CAACD,OAAO,CAAC8C,SAAS,GAAG7C,KAAI,CAACD,OAAO,CAAC8C,SAAS,GAAG,CAAC,CAAC,EACxD;QACD7C,KAAI,CAACS,kBAAkB,GAAGqC,SAAS;QAEnC9C,KAAI,CAAC+C,OAAO,CAACC,SAAS,CAACvC,kBAAkB,EAAE;UAC1CM,YAAY,EAAEf,KAAI,CAACkB,kBAAkB;UACrChB,qBAAqB,EAAEF,KAAI,CAACE,qBAAqB;UACjD+C,aAAa,EAAE;SACf,CAAC;;MAGH,IAAI,CAACjD,KAAI,CAACuC,OAAO,CAACC,UAAU,EAAE,EAAE;QAC/B;;MAGD,IAAMU,UAAU,GAAGlD,KAAI,CAACK,WAAW,CAACC,GAAG,CACtCN,KAAI,CAACuC,OAAO,CAACY,WAAW,EAAE,CAC1B;MACDnD,KAAI,CAACoD,gCAAgC,CAACF,UAAU,CAAC;MACjDlD,KAAI,CAAC+C,OAAO,CAACM,iBAAiB,EAAE;MAEhC,IAAInB,EAAC,CAACoB,UAAU,EAAEpB,EAAC,CAACqB,cAAc,EAAE;MAEpC;MACA,IAAMC,mBAAmB,GAAkB,CAAC3B,iBAAiB,IAAI,EAAE,EACjE4B,GAAG,CAAC,UAACC,GAAG;QAAA,OAAK1D,KAAI,CAAC2D,WAAW,CAACrD,GAAG,CAACoD,GAAG,CAAC;MAAA,EAAC,CACvCE,MAAM,CAAC,UAACpD,CAAC;QAAA,OAAK,CAAC,CAACA,CAAC;MAAA,EAAC;MAEpB;MACA,IAAMqD,eAAe,GAAG7D,KAAI,CAACD,OAAO,CAAC+D,4BAA4B,GAC9D9D,KAAI,CAACD,OAAO,CAAC+D,4BAA4B,CACzC/C,YAAY,CAAC0B,CAAC,EACd1B,YAAY,CAAC2B,CAAC,EACdc,mBAAmB,CAClB,GACDxD,KAAI,CAACoC,QAAQ,CAAC2B,iBAAiB,CAAChD,YAAY,CAAC0B,CAAC,EAAE1B,YAAY,CAAC2B,CAAC,CAAC;MAClE;MACA,IAAMsB,uBAAuB,GAAc,EAAE;MAC7C,KAAK,IAAMC,MAAM,IAAIJ,eAAe,EAAE;QACrC;QACA,IAAI,CAACA,eAAe,CAACjB,cAAc,CAACqB,MAAM,CAAC,EAAE;UAC5C;;QAED,IAAIC,WAAW,GAA+BL,eAAe,CAACI,MAAM,CAAC;QACrE,IAAIC,WAAW,IAAI,IAAI,EAAE;UACxBF,uBAAuB,CAACG,IAAI,CAACD,WAAW,CAAC;;QAE1C,OAAOA,WAAW,EAAE;UACnBA,WAAW,GAAGA,WAAW,CAACE,aAAa;UACvC,IACCF,WAAW,IACXF,uBAAuB,CAACK,OAAO,CAACH,WAAW,CAAC,KAAK,CAAC,CAAC,EAClD;YACDF,uBAAuB,CAACG,IAAI,CAACD,WAAW,CAAC;;;;MAI5C,IAAMI,wBAAwB,GAAaN,uBAAuB;MAAA,CAEhEJ,MAAM,CAAC,UAACW,IAAI;QAAA,OAAKf,mBAAmB,CAACa,OAAO,CAACE,IAAI,CAAgB,GAAG,CAAC,CAAC;MAAA,EAAC;MAAA,CAEvEd,GAAG,CAAC,UAACc,IAAI;QAAA,OAAKvE,KAAI,CAACwE,gBAAgB,CAACD,IAAI,CAAC;MAAA,EAAC;MAAA,CAE1CX,MAAM,CAAC,UAACW,IAAI;QAAA,OAAK,CAAC,CAACA,IAAI;MAAA,EAAC,CACxBX,MAAM,CAAC,UAACa,EAAE,EAAEC,KAAK,EAAEC,GAAG;QAAA,OAAKA,GAAG,CAACN,OAAO,CAACI,EAAE,CAAC,KAAKC,KAAK;MAAA,EAAC;MAEvD;MACA,IAAIrC,wBAAwB,EAAE;QAC7B,KAAK,IAAML,QAAQ,IAAIhC,KAAI,CAAC2D,WAAW,EAAE;UACxC,IAAMiB,UAAU,GAAG5E,KAAI,CAAC2D,WAAW,CAACrD,GAAG,CAAC0B,QAAQ,CAAC;UACjD,IACCkB,UAAU,IACV0B,UAAU,IACVA,UAAU,CAACC,QAAQ,CAAC3B,UAAU,CAAC,IAC/BoB,wBAAwB,CAACD,OAAO,CAACrC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAChD;YACDsC,wBAAwB,CAACzD,OAAO,CAACmB,QAAQ,CAAC;YAC1C;;;;MAKH;MACAsC,wBAAwB,CAACQ,OAAO,EAAE;MAElC9E,KAAI,CAAC+C,OAAO,CAACgC,KAAK,CAACT,wBAAwB,EAAE;QAC5CvD,YAAY,EAAEA;OACd,CAAC;KACF;IAED;;;;IAIA,KAAOyD,gBAAgB,GAAG,UAACD,IAAa,EAA6B;MACpE,IAAMS,IAAI,GAAGhF,KAAI,CAAC2D,WAAW,CAACqB,IAAI,EAAE;MACpC,IAAIC,IAAI,GAAGD,IAAI,CAACC,IAAI,EAAE;MACtB,OAAOA,IAAI,CAACC,IAAI,KAAK,KAAK,EAAE;QAC3B,IAAMlD,QAAQ,GAAGiD,IAAI,CAACE,KAAK;QAC3B,IAAIZ,IAAI,KAAKvE,KAAI,CAAC2D,WAAW,CAACrD,GAAG,CAAC0B,QAAQ,CAAC,EAAE;UAC5C,OAAOA,QAAQ;SACf,MAAM;UACNiD,IAAI,GAAGD,IAAI,CAACC,IAAI,EAAE;;;MAGpB,OAAOnC,SAAS;KAChB;IAED,KAAOsC,uBAAuB,GAAG,UAAC5E,CAAQ,EAAW;MACpDR,KAAI,CAACsC,YAAY,GAAG,KAAK;MACzBtC,KAAI,CAACgB,uBAAuB,GAAG8B,SAAS;MAExC,IAAI,CAACjE,kBAAkB,CAAC2B,CAAC,CAAe,EAAE;QACzC;;MAGD,IAAI,CAACR,KAAI,CAACuC,OAAO,CAACC,UAAU,EAAE,IAAIxC,KAAI,CAACuC,OAAO,CAAC8C,OAAO,EAAE,EAAE;QACzDrF,KAAI,CAACS,kBAAkB,GAAGqC,SAAS;QACnC;;MAGD,IAAItC,CAAC,CAAC8C,UAAU,EAAE9C,CAAC,CAAC+C,cAAc,EAAE;MAEpCvD,KAAI,CAACkB,kBAAkB,GAAG,EAAE;MAE5BlB,KAAI,CAACsF,kCAAkC,EAAE;MACzCtF,KAAI,CAAC+C,OAAO,CAACwC,IAAI,EAAE;MACnBvF,KAAI,CAAC+C,OAAO,CAACyC,OAAO,EAAE;KACtB;IAED,KAAOC,oBAAoB,GAAG,UAACjF,CAAgB,EAAW;MACzD,IAAIA,CAAC,CAACkD,GAAG,KAAK,QAAQ,IAAI1D,KAAI,CAACuC,OAAO,CAACC,UAAU,EAAE,EAAE;QACpDxC,KAAI,CAACkB,kBAAkB,GAAG,EAAE;QAE5BlB,KAAI,CAACsF,kCAAkC,EAAE;QACzCtF,KAAI,CAAC+C,OAAO,CAACyC,OAAO,EAAE;;KAEvB;IAngBA,IAAI,CAACzF,OAAO,GAAG,IAAIvB,aAAa,CAACuB,OAAO,EAAED,OAAO,CAAC;IAClD,IAAI,CAACiD,OAAO,GAAGlD,OAAO,CAAC6F,UAAU,EAAE;IACnC,IAAI,CAACnD,OAAO,GAAG1C,OAAO,CAAC8F,UAAU,EAAE;IAEnC,IAAI,CAACtF,WAAW,GAAG,IAAIuF,GAAG,EAAE;IAC5B,IAAI,CAACC,kBAAkB,GAAG,IAAID,GAAG,EAAE;IACnC,IAAI,CAACE,wBAAwB,GAAG,IAAIF,GAAG,EAAE;IACzC,IAAI,CAACjC,WAAW,GAAG,IAAIiC,GAAG,EAAE;IAC5B,IAAI,CAACG,aAAa,GAAG,EAAE;IACvB,IAAI,CAAC7E,kBAAkB,GAAG,EAAE;IAC5B,IAAI,CAACoB,YAAY,GAAG,KAAK;IAEzB,IAAI,IAAI,CAACvC,OAAO,CAACiG,iBAAiB,EAAE;MACnC,IAAI,CAACD,aAAa,CAAC5B,IAAI,CAAC5F,YAAY,CAACa,KAAK,CAAC;;IAG5C,IAAI,IAAI,CAACW,OAAO,CAACkG,iBAAiB,EAAE;MACnC,IAAI,CAACF,aAAa,CAAC5B,IAAI,CAAC5F,YAAY,CAACkB,KAAK,CAAC;;IAG5C,IAAI,IAAI,CAACM,OAAO,CAACmG,oBAAoB,EAAE;MACtC,IAAI,CAACH,aAAa,CAAC5B,IAAI,CAAC5F,YAAY,CAACmB,QAAQ,CAAC;;;EAE/CyG,YAAA,CAAAvG,gBAAA;IAAA8D,GAAA;IAAAyB,KAAA;IAED;;;IAGA,SAAAiB,QAAA,EAAyC;UAMpBC,GAAsB;MAL1C,OAAO;QACNhG,WAAW,EAAE,IAAI,CAACA,WAAW,CAACiG,IAAI;QAClCT,kBAAkB,EAAE,IAAI,CAACA,kBAAkB,CAACS,IAAI;QAChDR,wBAAwB,EAAE,IAAI,CAACA,wBAAwB,CAACQ,IAAI;QAC5D3C,WAAW,EAAE,IAAI,CAACA,WAAW,CAAC2C,IAAI;QAClCzE,iBAAiB,EAAE,EAAAwE,GAAsB,GAAtB,IAAI,CAACxE,iBAAiB,cAAtBwE,GAAsB,WAAQ,GAA9B,MAA8B,GAA9BA,GAAsB,CAAEE,MAAM,KAAI;OACrD;;IAGF;EAAA;IAAA7C,GAAA;IAAApD,GAAA,EACA,SAAAA,IAAA,EAA4C;MAC3C,OAAO,IAAI,CAACP,OAAO,CAACqC,QAAQ;;EAC5B;IAAAsB,GAAA;IAAAyB,KAAA,EAED,SAAAqB,MAAA,EAAqB;MACpB,IAAMC,IAAI,GAAG,IAAI,CAAC1G,OAAO,CAAC2G,WAAW;MACrC,IAAI,CAACD,IAAI,EAAE;QACV;;MAGDnI,SAAS,CACR,CAACsB,gBAAgB,CAAC+G,OAAO,EACzB,kDAAkD,CAClD;MACD/G,gBAAgB,CAAC+G,OAAO,GAAG,IAAI;MAE/B,IAAI,CAACC,gBAAgB,CAACH,IAAI,EAAE,OAAO,EAAE,IAAI,CAACI,sBAAsB,EAAE,CAAQ;MAC1E,IAAI,CAACD,gBAAgB,CACpBH,IAAI,EACJ,OAAO,EACP,IAAI,CAAClG,yBAAyB,EAC9B,IAAI,CACJ;MACD,IAAI,CAACqG,gBAAgB,CAACH,IAAI,EAAE,MAAM,EAAE,IAAI,CAACxE,aAAa,CAAQ;MAC9D,IAAI,CAAC2E,gBAAgB,CAACH,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC7E,oBAAoB,EAAE,IAAI,CAAC;MACpE,IAAI,CAACgF,gBAAgB,CACpBH,IAAI,EACJ,KAAK,EACL,IAAI,CAACrB,uBAAuB,EAC5B,IAAI,CACJ;MAED,IAAI,IAAI,CAACrF,OAAO,CAACiG,iBAAiB,IAAI,CAAC,IAAI,CAACjG,OAAO,CAAC+G,iBAAiB,EAAE;QACtE,IAAI,CAACF,gBAAgB,CACpBH,IAAI,EACJ,aAAa,EACb,IAAI,CAACrB,uBAAuB,CAC5B;;MAGF,IAAI,IAAI,CAACrF,OAAO,CAACmG,oBAAoB,EAAE;QACtC,IAAI,CAACU,gBAAgB,CACpBH,IAAI,EACJ,SAAS,EACT,IAAI,CAAChB,oBAAoB,EACzB,IAAI,CACJ;;;EAEF;IAAA/B,GAAA;IAAAyB,KAAA,EAED,SAAA4B,SAAA,EAAwB;MACvB,IAAMN,IAAI,GAAG,IAAI,CAAC1G,OAAO,CAAC2G,WAAW;MACrC,IAAI,CAACD,IAAI,EAAE;QACV;;MAGD7G,gBAAgB,CAAC+G,OAAO,GAAG,KAAK;MAChC,IAAI,CAACzF,kBAAkB,GAAG,EAAE;MAE5B,IAAI,CAAC8F,mBAAmB,CACvBP,IAAI,EACJ,OAAO,EACP,IAAI,CAAClG,yBAAyB,EAC9B,IAAI,CACJ;MACD,IAAI,CAACyG,mBAAmB,CAACP,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC3F,kBAAkB,CAAQ;MACvE,IAAI,CAACkG,mBAAmB,CAACP,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC7E,oBAAoB,EAAE,IAAI,CAAC;MACvE,IAAI,CAACoF,mBAAmB,CAACP,IAAI,EAAE,MAAM,EAAE,IAAI,CAACxE,aAAa,CAAQ;MACjE,IAAI,CAAC+E,mBAAmB,CACvBP,IAAI,EACJ,KAAK,EACL,IAAI,CAACrB,uBAAuB,EAC5B,IAAI,CACJ;MAED,IAAI,IAAI,CAACrF,OAAO,CAACiG,iBAAiB,IAAI,CAAC,IAAI,CAACjG,OAAO,CAAC+G,iBAAiB,EAAE;QACtE,IAAI,CAACE,mBAAmB,CACvBP,IAAI,EACJ,aAAa,EACb,IAAI,CAACrB,uBAAuB,CAC5B;;MAGF,IAAI,IAAI,CAACrF,OAAO,CAACmG,oBAAoB,EAAE;QACtC,IAAI,CAACc,mBAAmB,CACvBP,IAAI,EACJ,SAAS,EACT,IAAI,CAAChB,oBAAoB,EACzB,IAAI,CACJ;;MAGF,IAAI,CAACH,kCAAkC,EAAE;;EACzC;IAAA5B,GAAA;IAAAyB,KAAA,EAED,SAAAyB,iBACCK,OAAa,EACbC,KAAQ,EACRC,OAAyB,EAExB;MAAA,IADDC,OAAO,GAAAC,SAAA,CAAAd,MAAA,QAAAc,SAAA,QAAAvE,SAAA,GAAAuE,SAAA,MAAG,KAAK;MAEf,IAAMtH,OAAO,GAAGf,eAAe,GAAG;QAAEoI,OAAO,EAAPA,OAAO;QAAEE,OAAO,EAAE;OAAO,GAAGF,OAAO;MAEvE,IAAI,CAACrB,aAAa,CAACwB,OAAO,CAAC,UAAUC,YAAY,EAAE;QAClD,IAAMC,GAAG,GAAGxI,UAAU,CAACuI,YAAY,CAAC,CAACN,KAAK,CAAC;QAE3C,IAAIO,GAAG,EAAE;UACRR,OAAO,CAACL,gBAAgB,CAACa,GAAG,EAASN,OAAO,EAASpH,OAAO,CAAC;;OAE9D,CAAC;;EACF;IAAA2D,GAAA;IAAAyB,KAAA,EAED,SAAA6B,oBACCC,OAAa,EACbC,KAAQ,EACRC,OAAyB,EAExB;MAAA,IADDC,OAAO,GAAAC,SAAA,CAAAd,MAAA,QAAAc,SAAA,QAAAvE,SAAA,GAAAuE,SAAA,MAAG,KAAK;MAEf,IAAMtH,OAAO,GAAGf,eAAe,GAAG;QAAEoI,OAAO,EAAPA,OAAO;QAAEE,OAAO,EAAE;OAAO,GAAGF,OAAO;MAEvE,IAAI,CAACrB,aAAa,CAACwB,OAAO,CAAC,UAAUC,YAAY,EAAE;QAClD,IAAMC,GAAG,GAAGxI,UAAU,CAACuI,YAAY,CAAC,CAACN,KAAK,CAAC;QAE3C,IAAIO,GAAG,EAAE;UACRR,OAAO,CAACD,mBAAmB,CAACS,GAAG,EAASN,OAAO,EAASpH,OAAO,CAAC;;OAEjE,CAAC;;EACF;IAAA2D,GAAA;IAAAyB,KAAA,EAED,SAAAuC,kBAAyBvH,QAAgB,EAAEoE,IAAiB,EAAe;MAAA,IAAAoD,MAAA;MAC1E,IAAMjH,eAAe,GAAG,IAAI,CAACA,eAAe,CAACiB,IAAI,CAAC,IAAI,EAAExB,QAAQ,CAAC;MACjE,IAAI,CAACE,WAAW,CAACuH,GAAG,CAACzH,QAAQ,EAAEoE,IAAI,CAAC;MAEpC,IAAI,CAACqC,gBAAgB,CAACrC,IAAI,EAAE,OAAO,EAAE7D,eAAe,CAAC;MAErD,OAAO,YAAY;QAClBiH,MAAI,CAACtH,WAAW,CAACwH,MAAM,CAAC1H,QAAQ,CAAC;QACjCwH,MAAI,CAACX,mBAAmB,CAACzC,IAAI,EAAE,OAAO,EAAE7D,eAAe,CAAC;OACxD;;EACD;IAAAgD,GAAA;IAAAyB,KAAA,EAED,SAAA2C,mBACC3H,QAAgB,EAChBoE,IAAiB,EACjBxE,OAAgB,EACF;MAAA,IAAAgI,MAAA;MACd,IAAI,CAACjC,wBAAwB,CAAC8B,GAAG,CAACzH,QAAQ,EAAEJ,OAAO,CAAC;MACpD,IAAI,CAAC8F,kBAAkB,CAAC+B,GAAG,CAACzH,QAAQ,EAAEoE,IAAI,CAAC;MAE3C,OAAO,YAAY;QAClBwD,MAAI,CAAClC,kBAAkB,CAACgC,MAAM,CAAC1H,QAAQ,CAAC;QACxC4H,MAAI,CAACjC,wBAAwB,CAAC+B,MAAM,CAAC1H,QAAQ,CAAC;OAC9C;;EACD;IAAAuD,GAAA;IAAAyB,KAAA,EAED,SAAA6C,kBAAyBhG,QAAgB,EAAEuC,IAAiB,EAAe;MAAA,IAAA0D,MAAA;MAC1E,IAAMxB,IAAI,GAAG,IAAI,CAAC1G,OAAO,CAAC2G,WAAW;MACrC,IAAI,CAAC,IAAI,CAACtE,QAAQ,IAAI,CAACqE,IAAI,EAAE;QAC5B,OAAO,YAAY;UAClB,WACA;;MAGF,IAAM3E,UAAU,GAAG,SAAbA,UAAUA,CAAItB,CAA0B,EAAK;QAClD,IAAI,CAACyH,MAAI,CAAC7F,QAAQ,IAAI,CAACqE,IAAI,IAAI,CAACwB,MAAI,CAAC1F,OAAO,CAACC,UAAU,EAAE,EAAE;UAC1D;;QAGD,IAAI0F,MAAM;QAEV;;;QAGA,QAAQ1H,CAAC,CAACc,IAAI;UACb,KAAKrC,UAAU,CAACG,KAAK,CAACE,IAAI;YACzB4I,MAAM,GAAG;cACRzF,CAAC,EAAEjC,CAAE,CAAgB2H,OAAO;cAC5BzF,CAAC,EAAElC,CAAE,CAAgB4H;aACrB;YACD;UAED,KAAKnJ,UAAU,CAACQ,KAAK,CAACH,IAAI;gBAErB+G,GAA4B,EAC5BgC,IAA4B;YAFhCH,MAAM,GAAG;cACRzF,CAAC,EAAE,EAAA4D,GAA4B,GAA5B7F,CAAE,CAAgB8H,OAAO,CAAC,CAAC,CAAC,cAA5BjC,GAA4B,WAAS,GAArC,MAAqC,GAArCA,GAA4B,CAAE8B,OAAO,KAAI,CAAC;cAC7CzF,CAAC,EAAE,EAAA2F,IAA4B,GAA5B7H,CAAE,CAAgB8H,OAAO,CAAC,CAAC,CAAC,cAA5BD,IAA4B,WAAS,GAArC,MAAqC,GAArCA,IAA4B,CAAED,OAAO,KAAI;aAC5C;YACD;;QAGF;;;;QAIA,IAAMG,SAAS,GACdL,MAAM,IAAI,IAAI,GACXD,MAAI,CAAC7F,QAAQ,CAACoG,gBAAgB,CAACN,MAAM,CAACzF,CAAC,EAAEyF,MAAM,CAACxF,CAAC,CAAC,GAClDI,SAAS;QACb,IAAM2F,UAAU,GAAGF,SAAS,IAAIhE,IAAI,CAACM,QAAQ,CAAC0D,SAAS,CAAC;QAExD,IAAIA,SAAS,KAAKhE,IAAI,IAAIkE,UAAU,EAAE;UACrC,OAAOR,MAAI,CAACnG,UAAU,CAACtB,CAAC,EAAEwB,QAAQ,CAAC;;OAEpC;MAED;;;MAGA,IAAI,CAAC4E,gBAAgB,CAAC,IAAI,CAACxE,QAAQ,CAACsG,IAAI,EAAE,MAAM,EAAE5G,UAAU,CAAQ;MACpE,IAAI,CAAC6B,WAAW,CAACiE,GAAG,CAAC5F,QAAQ,EAAEuC,IAAI,CAAC;MAEpC,OAAO,YAAY;QAClB,IAAI0D,MAAI,CAAC7F,QAAQ,EAAE;UAClB6F,MAAI,CAACtE,WAAW,CAACkE,MAAM,CAAC7F,QAAQ,CAAC;UACjCiG,MAAI,CAACjB,mBAAmB,CAACiB,MAAI,CAAC7F,QAAQ,CAACsG,IAAI,EAAE,MAAM,EAAE5G,UAAU,CAAQ;;OAExE;;EACD;IAAA4B,GAAA;IAAAyB,KAAA,EAuBD,SAAA0B,uBAAA,EAAiC;MAChC,IAAI,CAAC,IAAI,CAAC9G,OAAO,CAACwB,eAAe,IAAI,CAAC,IAAI,CAACxB,OAAO,CAACyB,eAAe,EAAE;QACnE,OAAO,IAAI,CAACV,kBAAkB;;MAG/B,OAAO,IAAI,CAACM,uBAAuB;;EACnC;IAAAsC,GAAA;IAAAyB,KAAA,EAyOD,SAAA/B,iCAAyCmB,IAA6B,EAAE;MAAA,IAAAoE,MAAA;MACvE,IAAI,CAACrD,kCAAkC,EAAE;MAEzC,IAAI,CAACsD,iBAAiB,GAAGrE,IAAI;MAC7B,IAAI,CAACsE,gCAAgC,GAAG,IAAIC,gBAAgB,CAAC,YAAM;QAClE,IAAIvE,IAAI,IAAI,CAACA,IAAI,CAACH,aAAa,EAAE;UAChCuE,MAAI,CAACI,mBAAmB,EAAE;UAC1BJ,MAAI,CAACrD,kCAAkC,EAAE;;OAE1C,CAAC;MAEF,IAAI,CAACf,IAAI,IAAI,CAACA,IAAI,CAACH,aAAa,EAAE;QACjC;;MAGD,IAAI,CAACyE,gCAAgC,CAACG,OAAO,CAACzE,IAAI,CAACH,aAAa,EAAE;QACjE6E,SAAS,EAAE;OACX,CAAC;;EACF;IAAAvF,GAAA;IAAAyB,KAAA,EAED,SAAA4D,oBAAA,EAA8B;MAC7B,IAAI,IAAI,CAAC3G,QAAQ,IAAI,IAAI,CAACwG,iBAAiB,EAAE;QAC5C,IAAI,CAACA,iBAAiB,CAACM,KAAK,CAACC,OAAO,GAAG,MAAM;QAC7C,IAAI,CAACP,iBAAiB,CAACQ,eAAe,CAAC,cAAc,CAAC;QACtD,IAAI,CAAChH,QAAQ,CAACsG,IAAI,CAACW,WAAW,CAAC,IAAI,CAACT,iBAAiB,CAAC;;;EAEvD;IAAAlF,GAAA;IAAAyB,KAAA,EAED,SAAAG,mCAAA,EAA6C;MAC5C,IAAI,IAAI,CAACuD,gCAAgC,EAAE;QAC1C,IAAI,CAACA,gCAAgC,CAACS,UAAU,EAAE;;MAGnD,IAAI,CAACT,gCAAgC,GAAG/F,SAAS;MACjD,IAAI,CAAC8F,iBAAiB,GAAG9F,SAAS;;EAClC;EAAA,OAAAlD,gBAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}