{"ast":null,"code":"import { parseRootMargin, shallowCompare } from './utils';\nexport var observerElementsMap = new Map();\nexport function getPooled(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var root = options.root || null;\n  var rootMargin = parseRootMargin(options.rootMargin);\n  var threshold = Array.isArray(options.threshold) ? options.threshold : [options.threshold != null ? options.threshold : 0];\n  var observers = observerElementsMap.keys();\n  var observer;\n  while (observer = observers.next().value) {\n    var unmatched = root !== observer.root || rootMargin !== observer.rootMargin || shallowCompare(threshold, observer.thresholds);\n    if (!unmatched) {\n      return observer;\n    }\n  }\n  return null;\n}\nexport function findObserverElement(observer, entry) {\n  var elements = observerElementsMap.get(observer);\n  if (elements) {\n    var values = elements.values();\n    var element = void 0;\n    while (element = values.next().value) {\n      if (element.target === entry.target) {\n        return element;\n      }\n    }\n  }\n  return null;\n}\n/**\n * The Intersection Observer API callback that is called whenever one element\n * – namely the target – intersects either the device viewport or a specified element.\n * Also will get called whenever the visibility of the target element changes and\n * crosses desired amounts of intersection with the root.\n */\nexport function callback(entries, observer) {\n  for (var i = 0; i < entries.length; i++) {\n    var element = findObserverElement(observer, entries[i]);\n    /* istanbul ignore next line */\n    if (element) {\n      element.handleChange(entries[i]);\n    }\n  }\n}\nexport function createObserver(options) {\n  var pooled = getPooled(options);\n  if (pooled) {\n    return pooled;\n  }\n  var observer = new IntersectionObserver(callback, options);\n  observerElementsMap.set(observer, new Set());\n  return observer;\n}\nexport function observeElement(element) {\n  var _a;\n  if (element.observer && !observerElementsMap.has(element.observer)) {\n    observerElementsMap.set(element.observer, new Set());\n  }\n  (_a = observerElementsMap.get(element.observer)) === null || _a === void 0 ? void 0 : _a.add(element);\n  element.observer.observe(element.target);\n}\nexport function unobserveElement(element, target) {\n  if (observerElementsMap.has(element.observer)) {\n    var targets = observerElementsMap.get(element.observer);\n    if (targets === null || targets === void 0 ? void 0 : targets.delete(element)) {\n      if (targets.size > 0) {\n        element.observer.unobserve(target);\n      } else {\n        element.observer.disconnect();\n        observerElementsMap.delete(element.observer);\n      }\n    }\n  }\n}","map":{"version":3,"names":["parseRootMargin","shallowCompare","observerElementsMap","Map","getPooled","options","root","rootMargin","threshold","Array","isArray","observers","keys","observer","next","value","unmatched","thresholds","findObserverElement","entry","elements","get","values","element","target","callback","entries","i","length","handleChange","createObserver","pooled","IntersectionObserver","set","Set","observeElement","_a","has","add","observe","unobserveElement","targets","delete","size","unobserve","disconnect"],"sources":["C:/Users/oyeti/Documents/GitHub/HNG_Stage-Three/node_modules/react-progressive-graceful-image/node_modules/@researchgate/react-intersection-observer/lib/es/observer.js"],"sourcesContent":["import { parseRootMargin, shallowCompare } from './utils';\nexport var observerElementsMap = new Map();\nexport function getPooled(options) {\n    if (options === void 0) { options = {}; }\n    var root = options.root || null;\n    var rootMargin = parseRootMargin(options.rootMargin);\n    var threshold = Array.isArray(options.threshold)\n        ? options.threshold\n        : [options.threshold != null ? options.threshold : 0];\n    var observers = observerElementsMap.keys();\n    var observer;\n    while ((observer = observers.next().value)) {\n        var unmatched = root !== observer.root ||\n            rootMargin !== observer.rootMargin ||\n            shallowCompare(threshold, observer.thresholds);\n        if (!unmatched) {\n            return observer;\n        }\n    }\n    return null;\n}\nexport function findObserverElement(observer, entry) {\n    var elements = observerElementsMap.get(observer);\n    if (elements) {\n        var values = elements.values();\n        var element = void 0;\n        while ((element = values.next().value)) {\n            if (element.target === entry.target) {\n                return element;\n            }\n        }\n    }\n    return null;\n}\n/**\n * The Intersection Observer API callback that is called whenever one element\n * – namely the target – intersects either the device viewport or a specified element.\n * Also will get called whenever the visibility of the target element changes and\n * crosses desired amounts of intersection with the root.\n */\nexport function callback(entries, observer) {\n    for (var i = 0; i < entries.length; i++) {\n        var element = findObserverElement(observer, entries[i]);\n        /* istanbul ignore next line */\n        if (element) {\n            element.handleChange(entries[i]);\n        }\n    }\n}\nexport function createObserver(options) {\n    var pooled = getPooled(options);\n    if (pooled) {\n        return pooled;\n    }\n    var observer = new IntersectionObserver(callback, options);\n    observerElementsMap.set(observer, new Set());\n    return observer;\n}\nexport function observeElement(element) {\n    var _a;\n    if (element.observer && !observerElementsMap.has(element.observer)) {\n        observerElementsMap.set(element.observer, new Set());\n    }\n    (_a = observerElementsMap.get(element.observer)) === null || _a === void 0 ? void 0 : _a.add(element);\n    element.observer.observe(element.target);\n}\nexport function unobserveElement(element, target) {\n    if (observerElementsMap.has(element.observer)) {\n        var targets = observerElementsMap.get(element.observer);\n        if (targets === null || targets === void 0 ? void 0 : targets.delete(element)) {\n            if (targets.size > 0) {\n                element.observer.unobserve(target);\n            }\n            else {\n                element.observer.disconnect();\n                observerElementsMap.delete(element.observer);\n            }\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}